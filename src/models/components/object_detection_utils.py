import torch
from torchvision import ops


def match_proposed_boxes_to_true(
        true_boxes: torch.Tensor, 
        proposed_boxes: torch.Tensor, 
        min_num_positives: int, 
        in_format: str = 'xywh', 
        true_box_labels: torch.Tensor = None, 
        positivity_threshold: float = 0.7, 
        negativity_threshold: float = 0.3
    ):
    """Matches proposed bounding boxes to a tensor of ground truth bounding boxes
       and returns a tensor of labels indicating positive (1, object) or negative 
       (0, no object) or inconclusive (-1) for each match based on whether 
       a certain IoU threshold with a ground truth box is met. This labeling is done
       according to specified thresholds and also with a specified minimum number 
       of positives. If the positivity threshold does not generate enough positives,
       they will be generated by choosing the ones with the best overlap.

    Args:
        true_boxes (torch.Tensor): A tensor of boxes of shape (N, 4)
        
        proposed_boxes (torch.Tensor): A tensor of boxes of shape (M, 4)
        
        min_num_positives (int): minimum number of positives generated by the matching
        
        in_format (str, optional): string specifying the string format - 
        see torchvision ops documentation.Defaults to 'xywh'.
        
        box_labels (torch.Tensor, optiona): tensor of shape (N) giving the class labels
        corresponding with the ground truth boxes. 
        
        positivity_threshold (float, optional): Above this threshold a proposed box will 
        be considered to match with the ground truth. Defaults to 0.7.
        
        negativity_threshold (float, optional): below this threshold a box will be considered 
        to be background. Defaults to 0.3.

    Returns:
        [type]: [description]
    """
    assert len(true_boxes.shape) == 2
    assert len(proposed_boxes.shape) == 2
    
    num_true_boxes, _ = true_boxes.shape
    num_proposed_boxes, _ = proposed_boxes.shape

    ious = ops.box_iou(
        ops.box_convert(proposed_boxes, in_fmt=in_format, out_fmt='xyxy'),
        ops.box_convert(true_boxes, in_fmt=in_format, out_fmt='xyxy')
    )
    
    max_ious = torch.max(ious, dim=-1, )
    matching_true_boxes = true_boxes[max_ious.indices]
    if true_box_labels is not None:
        matching_true_box_labels = true_box_labels[max_ious.indices]
    
    labels = (torch.ones_like(max_ious.values) * -1).long()
    indices = torch.tensor(range(len(labels)))

    negative_indices = indices[max_ious.values < negativity_threshold]

    labels[negative_indices] = 0

    positive_indices = indices[max_ious.values >= positivity_threshold]
    if len(positive_indices) < min_num_positives:
        positive_indices = torch.sort(max_ious.values, dim=-1, descending=True).indices[:min_num_positives]

    if true_box_labels is not None: 
        labels[positive_indices] = matching_true_box_labels[positive_indices] 
    else:
        labels[positive_indices] = 1
    
    return {
        'matching_true_boxes': matching_true_boxes, 
        'proposed_boxes': proposed_boxes,
        'labels': labels,
        'iou_scores': max_ious.values
    }
    
    
def boxreg_transform(regression_scores, anchor_boxes, in_fmt='xywh'):
    """Apply the box regression transform along the last axis of the input.

    Args:
        regression_scores ([type]): a tensor of shape (N, 4), where the last dimension contains t_x, t_y, t_w, t_h
        anchor_boxes ([type]): a tensor of shape (N, 4) specifying the anchor boxes upon which the transofrm is being performed.
        in_fmt (str, optional): The format of the boxes. Defaults to 'xywh'.
    """
    
    # the transform requires 'cxcywh' format:
    anchor_boxes = ops.box_convert(anchor_boxes, in_fmt=in_fmt, out_fmt='cxcywh')
    
    x_a = anchor_boxes[:, 0]
    y_a = anchor_boxes[:, 1]
    w_a = anchor_boxes[:, 2]
    h_a = anchor_boxes[:, 3]
    
    t_x = regression_scores[:, 0]
    t_y = regression_scores[:, 1]
    t_w = regression_scores[:, 2]
    t_h = regression_scores[:, 3]
    
    x = ( t_x * w_a ) + x_a 
    y = ( t_y * h_a ) + y_a
    w = w_a * torch.exp(t_w)
    h = h_a * torch.exp(t_h)
    
    proposed_boxes = torch.stack( [x, y, w, h], dim=-1 )
    proposed_boxes = ops.box_convert(anchor_boxes, in_fmt='cxcywh', out_fmt=in_fmt)
    return proposed_boxes
    

def inverse_boxreg_transform(proposed_boxes, anchor_boxes, in_fmt='xywh'):
    """Obtain the transform parameters that would transform the given anchor boxes to the given 
    output ( proposed boxes )

    Args:
        proposed_boxes (Tensor): A tensor of shape (N, 4)
        anchor_boxes (Tensor): A tensor fo shape (N, 4)
        in_fmt (str, optional): The format of the boxes. Defaults to 'xywh'.
    """
    
    anchor_boxes = ops.box_convert(anchor_boxes, in_fmt=in_fmt, out_fmt='cxcywh')
    proposed_boxes = ops.box_convert(proposed_boxes, in_fmt=in_fmt, out_fmt='cxcywh')
    
    x_a = anchor_boxes[:, 0]
    y_a = anchor_boxes[:, 1]
    w_a = anchor_boxes[:, 2]
    h_a = anchor_boxes[:, 3]
    
    x = proposed_boxes[:, 0]
    y = proposed_boxes[:, 1]
    w = proposed_boxes[:, 2]
    h = proposed_boxes[:, 3]
    
    t_x = ( x - x_a ) / w_a
    t_y = ( y - y_a ) / h_a 
    t_w = torch.log( w / w_a )
    t_h = torch.log( h / h_a)
    
    transform_parameters = torch.stack( [t_x, t_y, t_w, t_h], dim=-1 )
    return transform_parameters
    
    
def select_training_examples(
    proposed_boxes: torch.Tensor, 
    anchor_boxes: torch.Tensor, 
    regression_scores: torch.Tensor, 
    objectness_scores: torch.Tensor, 
    true_boxes: torch.Tensor, 
    num_training_examples,
    min_num_positives, 
    positivity_threshold: float = 0.7, 
    negativity_threshold: float = 0.3, 
    true_box_labels = None
):

    box_matching_output = match_proposed_boxes_to_true(
        true_boxes, 
        proposed_boxes, 
        min_num_positives, 
        true_box_labels=true_box_labels,
        positivity_threshold=positivity_threshold, 
        negativity_threshold=negativity_threshold
    )

    labels = box_matching_output['labels']
    matching_true_boxes = box_matching_output['matching_true_boxes']
    
    target_regression_scores = inverse_boxreg_transform(
        matching_true_boxes, anchor_boxes
    )
    
    indices_for_loss = torch.tensor(range(len(labels))).long()

    indices_for_loss_positive = indices_for_loss[labels > 0]
    indices_for_loss_negative = indices_for_loss[labels == 0]

    indices_for_loss_positive = indices_for_loss_positive[torch.randperm(len(indices_for_loss_positive))]
    if len(indices_for_loss_positive) >= num_training_examples//2:
        indices_for_loss_positive = indices_for_loss_positive[:num_training_examples//2]

    indices_for_loss_negative = indices_for_loss_negative[torch.randperm(len(indices_for_loss_negative))]
    indices_for_loss_negative = indices_for_loss_negative[:num_training_examples - len(indices_for_loss_positive)]

    indices_for_loss = torch.concat([indices_for_loss_negative, indices_for_loss_positive])
    
    reg_scores_for_loss = regression_scores[indices_for_loss]
    target_reg_scores_for_loss = target_regression_scores[indices_for_loss]

    objectness_scores_for_loss = objectness_scores[indices_for_loss]
    labels_for_loss = labels[indices_for_loss]

    iou_scores_for_loss = box_matching_output['iou_scores'][indices_for_loss]

    return {
        'regression_scores': reg_scores_for_loss, 
        'target_regression_scores': target_reg_scores_for_loss, 
        'objectness_scores': objectness_scores_for_loss, 
        'labels': labels_for_loss,
        'iou_scores': iou_scores_for_loss
    }
    
    
